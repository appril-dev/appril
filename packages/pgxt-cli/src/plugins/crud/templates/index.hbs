import api, {
  type DefaultState,
  type DefaultContext,
  type ParameterizedContext,
  type Middleware,
  type UseOpt,
  type UseSpec,
  type RouteSpec,
} from "@appril/api";

import type { QueryBuilder } from "@appril/dbxt";
import type { Knex } from "knex";

export type Pager = {
  totalItems: number;
  totalPages: number;
  currentPage: number;
  nextPage: number;
  prevPage: number;
  offset: number;
};

export const config = {
  primaryKey: "id",
  itemsPerPage: 25,
  sidePages: 4,
};

export default <
  TableName extends Knex.TableNames,
  ColumnT
>(
  dbxt: QueryBuilder<TableName>,
  columns: readonly ColumnT[],
  opt: {
    primaryKey?: string;
    itemsPerPage?: number;
    sidePages?: number;
  },
) => {

  type CrudContext = {
    readonly dbxt: QueryBuilder<TableName>;
    readonly queryBuilder: QueryBuilder<TableName>;
    readonly primaryKey: string;
    returning?: readonly ColumnT[] | Knex.Raw;
    returningExclude?: readonly ColumnT[] | Knex.Raw;
  };

  type WrapperContext<
    StateT,
    ContextT,
    ParamsT
  > = ParameterizedContext<
    DefaultState & StateT,
    DefaultContext & ContextT & { params: ParamsT; crud: CrudContext }
  >

  type WrapperMiddleware<
    StateT,
    ContextT,
    ParamsT
  > = Middleware<
    DefaultState & StateT,
    WrapperContext<StateT, ContextT, ParamsT>
  >

  interface Wrapper<
    ParamsT,
    WorkerT
  > {
    <
      StateT = object,
      ContextT = object
    >(
      handler: (
        ctx: WrapperContext<StateT, ContextT, ParamsT>,
        worker: WorkerT,
      ) => Promise<unknown>,
    ): RouteSpec;
  }

  interface UseWrapper<
    ParamsT
  > {
    <
      StateT = object,
      ContextT = object,
      T = WrapperMiddleware<StateT, ContextT, ParamsT>
    >(
      use: T | Array<T>,
    ): UseSpec;
    <
      StateT = object,
      ContextT = object,
      T = WrapperMiddleware<StateT, ContextT, ParamsT>
    >(
      use: T | Array<T>,
      opt?: UseOpt,
    ): UseSpec;
  }

  type GenericMiddleware = Middleware<DefaultState, {
    params: Record<string, string>;
    crud: CrudContext;
  }>;

  function useWrapper<ParamsT>(): UseWrapper<
    ParamsT
  > {
    return (use, opt?: UseOpt) => {
      return api.use([initMiddleware, use].flat() as Array<never>, opt)
    }
  }

  function createWrapper<ParamsT, WorkerT>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("post", [
        initMiddleware,
        async (ctx, next) => {
          const worker = async (data: never) => {
            const [item] = await ctx.crud.dbxt
              .insert(data)
              .returning(ctx.crud.returning as readonly string[]);
            return item;
          }
          ctx.body = await handler(ctx as never, worker as never)
          return next();
        }
      ] as Array<GenericMiddleware>)
    }
  }

  function updateWrapper<ParamsT, WorkerT>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("patch", [
        initMiddleware,
        async (ctx, next) => {
          const worker = async (data: never) => {
            const updates = Object.entries(data).reduce((map: Record<string,unknown>, [k, v]) => {
              if (v !== undefined) {
                map[k] = v
              }
              return map
            }, {})

            const [item] = Object.keys(updates).length
              ? await ctx.crud.queryBuilder
                  .where(ctx.crud.primaryKey, ctx.params.id)
                  .update(data)
                  .returning(ctx.crud.returning as readonly string[])
              : await ctx.crud.dbxt
                  .where(ctx.crud.primaryKey, ctx.params.id)
                  .select(ctx.crud.returning as readonly string[])

            // @ts-expect-error https://github.com/DefinitelyTyped/DefinitelyTyped/issues/59300
            ctx.assert(item, 404);

            return item;
          }
          ctx.body = await handler(ctx as never, worker as never)
          return next()
        }
      ] as Array<GenericMiddleware>)
    }
  }

  function deleteWrapper<ParamsT, WorkerT>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("del", [
        initMiddleware,
        async (ctx, next) => {
          const worker = async () => {
            const [item] = await ctx.crud.queryBuilder
              .where(ctx.crud.primaryKey, ctx.params.id)
              .delete()
              .returning(ctx.crud.returning as readonly string[]);

            // @ts-expect-error https://github.com/DefinitelyTyped/DefinitelyTyped/issues/59300
            ctx.assert(item, 404);

            return item;
          }
          ctx.body = await handler(ctx as never, worker as never)
          return next()
        }
      ] as Array<GenericMiddleware>)
    }
  }

  function retrieveWrapper<ParamsT, WorkerT>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("get", [
        initMiddleware,
        async (ctx, next) => {
          const worker = async () => {
            const item = await ctx.crud.queryBuilder
              .where(ctx.crud.primaryKey, ctx.params.id)
              .first(ctx.crud.returning as readonly string[]);

            // @ts-expect-error https://github.com/DefinitelyTyped/DefinitelyTyped/issues/59300
            ctx.assert(item, 404);

            return item;
          }
          ctx.body = await handler(ctx as never, worker as never)
          return next()
        }
      ] as Array<GenericMiddleware>)
    }
  }

  function listWrapper<ParamsT, WorkerT>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("get", [
        initMiddleware,
        async (ctx, next) => {
          const worker = async () => {
            const { crud } = ctx;

            const totalItems = await crud.queryBuilder.clone().countRows();
            const totalPages = Math.ceil(totalItems / itemsPerPage);

            let currentPage = Number(ctx.query._page || 0);

            if (currentPage < 1) {
              currentPage = 1;
            }

            if (currentPage > totalPages) {
              currentPage = totalPages;
            }

            let nextPage = currentPage + 1;

            if (nextPage > totalPages) {
              nextPage = 0;
            }

            let prevPage = currentPage - 1;

            if (prevPage < 1) {
              prevPage = 0;
            }

            let minPage = currentPage - sidePages;

            if (currentPage + sidePages > totalPages) {
              minPage = totalPages - sidePages * 2;
            }

            if (minPage < 1) {
              minPage = 1;
            }

            let maxPage = currentPage + sidePages;

            if (currentPage < sidePages) {
              maxPage = sidePages * 2;
            }

            if (maxPage > totalPages) {
              maxPage = totalPages;
            }

            let offset = (currentPage - 1) * itemsPerPage;

            if (offset < 0) {
              offset = 0;
            }

            const pager = {
              totalItems,
              totalPages,
              currentPage,
              nextPage,
              prevPage,
              offset,
            } as Pager;

            const items = await crud.queryBuilder
              .select(ctx.crud.returning as readonly string[])
              .offset(offset)
              .limit(itemsPerPage);

            return {
              items,
              pager,
            };

          }
          ctx.body = await handler(ctx as never, worker as never)
          return next()
        }
      ] as Array<GenericMiddleware>)
    }
  }

  const { primaryKey, itemsPerPage, sidePages } = {
    ...config,
    ...opt,
  };

  let returning: readonly ColumnT[] | Knex.Raw | undefined
  let returningExclude: readonly ColumnT[] = []

  const crudContext: Record<
    keyof CrudContext,
    PropertyDescriptor
  > = {
    dbxt: {
      get() { return dbxt },
      enumerable: true,
    },
    queryBuilder: {
      get: dbxt.clone,
      enumerable: true,
    },
    primaryKey: {
      value: primaryKey,
      enumerable: true,
    },
    returning: {
      get() {
        return returning || (
          returningExclude.length
            ? columns.filter((e) => !returningExclude.includes(e))
            : "*"
        )
      },
      set(val) { returning = val },
      enumerable: true,
    },
    returningExclude: {
      get() { return returningExclude },
      set(val) { returningExclude = Array.isArray(val) ? val : [] },
      enumerable: true,
    },
  };

  const ctxExtend = {
    crud: Object.defineProperties({}, crudContext),
  };

  const initMiddleware: Middleware = (ctx, next) => {
    for (const [key, value] of Object.entries(ctxExtend)) {
      key in ctx ||
        Object.defineProperty(ctx, key, {
          value,
          configurable: false,
          writable: false,
          enumerable: true,
        });
    }
    return next();
  };

  return {
    useWrapper,
    createWrapper,
    updateWrapper,
    deleteWrapper,
    retrieveWrapper,
    listWrapper,
  };
};
