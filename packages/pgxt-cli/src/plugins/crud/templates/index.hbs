import api, {
  type DefaultState,
  type DefaultContext,
  type ParameterizedContext,
  type Middleware,
  type UseOpt,
  type UseSpec,
  type RouteSpec,
} from "@appril/api";

import type { QueryBuilder } from "@appril/dbxt";
import type { Knex } from "knex";

export type Pager = {
  totalItems: number;
  totalPages: number;
  currentPage: number;
  nextPage: number;
  prevPage: number;
  offset: number;
};

export const config = {
  primaryKey: "id",
  itemsPerPage: 25,
  sidePages: 4,
};

export default <TableName extends Knex.TableNames, ColumnT>(
  dbxt: QueryBuilder<TableName>,
  columns: readonly ColumnT[],
  opt: {
    primaryKey?: string;
    itemsPerPage?: number;
    sidePages?: number;
  },
) => {
  type CrudContext<WorkerT extends GenericWorker> = {
    readonly dbxt: QueryBuilder<TableName>;
    readonly queryBuilder: QueryBuilder<TableName>;
    readonly primaryKey: string;
    returning?: readonly ColumnT[] | Knex.Raw;
    returningExclude?: readonly ColumnT[] | Knex.Raw;
    worker: WorkerT;
  };

  type WrapperContext<
    StateT,
    ContextT,
    ParamsT,
    WorkerT extends GenericWorker,
  > = ParameterizedContext<
    DefaultState & StateT,
    DefaultContext & ContextT & { params: ParamsT; crud: CrudContext<WorkerT> },
    Awaited<ReturnType<WorkerT>>
  >;

  interface Wrapper<ParamsT, WorkerT extends GenericWorker> {
    <
      StateT = object,
      ContextT = object,
      ResponseBodyT = Awaited<ReturnType<WorkerT>>,
    >(
      handler: Middleware<
        StateT,
        WrapperContext<StateT, ContextT, ParamsT, WorkerT>,
        ResponseBodyT
      >,
    ): RouteSpec;
    <
      StateT = object,
      ContextT = object,
      ResponseBodyT = Awaited<ReturnType<WorkerT>>,
    >(
      handler: Array<
        Middleware<
          StateT,
          WrapperContext<StateT, ContextT, ParamsT, WorkerT>,
          ResponseBodyT
        >
      >,
    ): RouteSpec;
  }

  interface UseWrapper<ParamsT> {
    <
      StateT = object,
      ContextT = object,
      T = Middleware<
        StateT,
        WrapperContext<StateT, ContextT, ParamsT, GenericWorker>
      >,
    >(
      use: T | Array<T>,
    ): UseSpec;
    <
      StateT = object,
      ContextT = object,
      T = Middleware<
        StateT,
        WrapperContext<StateT, ContextT, ParamsT, GenericWorker>
      >,
    >(
      use: T | Array<T>,
      opt?: UseOpt,
    ): UseSpec;
  }

  type GenericWorker = (...args: Array<never>) => Promise<unknown>;

  function useWrapper<ParamsT>(): UseWrapper<ParamsT> {
    return (use, opt?: UseOpt) => {
      return api.use(
        [initMiddleware(async () => {}), use].flat() as Array<never>,
        opt,
      );
    };
  }

  function createWrapper<ParamsT, WorkerT extends GenericWorker>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("post", [
        initMiddleware(async function (
          this: WrapperContext<DefaultState, DefaultContext, ParamsT, WorkerT>,
          data,
        ) {
          const [item] = await this.crud.dbxt
            .insert(data as never)
            .returning(this.crud.returning as readonly string[]);
          return item;
        }),
        handler,
      ] as Array<never>);
    };
  }

  function updateWrapper<ParamsT, WorkerT extends GenericWorker>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("patch", [
        initMiddleware(async function (
          this: WrapperContext<DefaultState, DefaultContext, ParamsT, WorkerT>,
          data,
        ) {
          const updates = Object.entries(data as never).reduce(
            (map: Record<string, unknown>, [k, v]) => {
              if (v !== undefined) {
                map[k] = v;
              }
              return map;
            },
            {},
          );

          const { id } = this.params as { id: number };

          const [item] = Object.keys(updates).length
            ? await this.crud.queryBuilder
                .where(this.crud.primaryKey, id)
                .update(data as never)
                .returning(this.crud.returning as readonly string[])
            : await this.crud.dbxt
                .where(this.crud.primaryKey, id)
                .select(this.crud.returning as readonly string[]);

          this.assert(item, 404);

          return item;
        }),
        handler,
      ] as Array<never>);
    };
  }

  function deleteWrapper<ParamsT, WorkerT extends GenericWorker>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("del", [
        initMiddleware(async function (
          this: WrapperContext<DefaultState, DefaultContext, ParamsT, WorkerT>,
        ) {
          const { id } = this.params as { id: number };

          const [item] = await this.crud.queryBuilder
            .where(this.crud.primaryKey, id)
            .delete()
            .returning(this.crud.returning as readonly string[]);

          this.assert(item, 404);

          return item;
        }),
        handler,
      ] as Array<never>);
    };
  }

  function retrieveWrapper<ParamsT, WorkerT extends GenericWorker>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("get", [
        initMiddleware(async function (
          this: WrapperContext<DefaultState, DefaultContext, ParamsT, WorkerT>,
        ) {
          const { id } = this.params as { id: number };

          const item = await this.crud.queryBuilder
            .where(this.crud.primaryKey, id)
            .first(this.crud.returning as readonly string[]);

          this.assert(item, 404);

          return item;
        }),
        handler,
      ] as Array<never>);
    };
  }

  function listWrapper<ParamsT, WorkerT extends GenericWorker>(): Wrapper<
    ParamsT,
    WorkerT
  > {
    return (handler) => {
      return api.definitionFactory("get", [
        initMiddleware(async function (
          this: WrapperContext<DefaultState, DefaultContext, ParamsT, WorkerT>,
        ) {
          const { crud } = this;

          const totalItems = await crud.queryBuilder.clone().countRows();
          const totalPages = Math.ceil(totalItems / itemsPerPage);

          let currentPage = Number(this.query._page || 0);

          if (currentPage < 1) {
            currentPage = 1;
          }

          if (currentPage > totalPages) {
            currentPage = totalPages;
          }

          let nextPage = currentPage + 1;

          if (nextPage > totalPages) {
            nextPage = 0;
          }

          let prevPage = currentPage - 1;

          if (prevPage < 1) {
            prevPage = 0;
          }

          let minPage = currentPage - sidePages;

          if (currentPage + sidePages > totalPages) {
            minPage = totalPages - sidePages * 2;
          }

          if (minPage < 1) {
            minPage = 1;
          }

          let maxPage = currentPage + sidePages;

          if (currentPage < sidePages) {
            maxPage = sidePages * 2;
          }

          if (maxPage > totalPages) {
            maxPage = totalPages;
          }

          let offset = (currentPage - 1) * itemsPerPage;

          if (offset < 0) {
            offset = 0;
          }

          const pager = {
            totalItems,
            totalPages,
            currentPage,
            nextPage,
            prevPage,
            offset,
          } as Pager;

          const items = await crud.queryBuilder
            .select(crud.returning as readonly string[])
            .offset(offset)
            .limit(itemsPerPage);

          return {
            items,
            pager,
          };
        }),
        handler,
      ] as Array<never>);
    };
  }

  const { primaryKey, itemsPerPage, sidePages } = {
    ...config,
    ...opt,
  };

  let returning: readonly ColumnT[] | Knex.Raw | undefined;
  let returningExclude: readonly ColumnT[] = [];

  const crudContext = (
    worker: GenericWorker,
  ): Record<keyof CrudContext<GenericWorker>, PropertyDescriptor> => {
    return {
      worker: {
        value: worker,
        enumerable: true,
      },
      dbxt: {
        get() {
          return dbxt;
        },
        enumerable: true,
      },
      queryBuilder: {
        get: dbxt.clone,
        enumerable: true,
      },
      primaryKey: {
        value: primaryKey,
        enumerable: true,
      },
      returning: {
        get() {
          return (
            returning ||
            (returningExclude.length
              ? columns.filter((e) => !returningExclude.includes(e))
              : "*")
          );
        },
        set(val) {
          returning = val;
        },
        enumerable: true,
      },
      returningExclude: {
        get() {
          return returningExclude;
        },
        set(val) {
          returningExclude = Array.isArray(val) ? val : [];
        },
        enumerable: true,
      },
    };
  };

  const ctxExtend = (worker: GenericWorker) => {
    return { crud: Object.defineProperties({}, crudContext(worker)) };
  };

  const initMiddleware = (worker: GenericWorker): Middleware => {
    return (ctx, next) => {
      for (const [key, value] of Object.entries(ctxExtend(worker.bind(ctx)))) {
        key in ctx ||
          Object.defineProperty(ctx, key, {
            value,
            configurable: false,
            writable: false,
            enumerable: true,
          });
      }
      return next();
    };
  };

  return {
    useWrapper,
    createWrapper,
    updateWrapper,
    deleteWrapper,
    retrieveWrapper,
    listWrapper,
  };
};
