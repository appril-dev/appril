import crc32 from "crc/crc32";

import { sanitizePath } from "@appril/dev-utils";

import type { RouteSection } from "./types";

export { defaults } from "@appril/configs";
export * from "./types";

export const BANNER = `/**
* @generated by @appril/dev; do not modify manually!
*/`;

export function normalizeRoutePath(path: string): string {
  return sanitizePath(path)
    .replace(/\/+/g, "/")
    .replace(/^\/|\/$/g, "");
}

export function routeSections(path: string, file: string): Array<RouteSection> {
  // use only normalized paths here

  const requiredParamRegex = /^\[([^\]]+)\]$/;
  const optionalParamRegex = /^\[\[([^\]]+)\]\]$/;
  const restParamRegex = /^\[\.\.\.([^\]]+)\]$/;

  return path.split("/").map((orig, i) => {
    const [base, ext = ""] = orig.split(/(\.([\w\d-]+)$)/);

    let param: RouteSection["param"] | undefined;

    const paramSplitter = (regex: RegExp): { name: string } => {
      const name = base.replace(regex, "$1");

      if (!name) {
        throw new Error(`Invalid path in ${file}\n${path}`);
      }

      return {
        name,
      };
    };

    if (base.startsWith("[")) {
      // order is highly important!
      if (restParamRegex.test(base)) {
        param = {
          ...paramSplitter(restParamRegex),
          isRest: true,
          isOpt: false,
        };
      } else if (optionalParamRegex.test(base)) {
        param = {
          ...paramSplitter(optionalParamRegex),
          isRest: false,
          isOpt: true,
        };
      } else if (requiredParamRegex.test(base)) {
        param = {
          ...paramSplitter(requiredParamRegex),
          isRest: false,
          isOpt: false,
        };
      }
    }

    if (param && i === 0) {
      throw new Error(`Path should not start with a param - ${path}`);
    }

    return {
      orig,
      base,
      ext,
      param,
    } satisfies RouteSection;
  });
}

export function httpMethodByApi(apiMethod: string): string {
  return apiMethod === "del" ? "DELETE" : apiMethod.toUpperCase();
}
